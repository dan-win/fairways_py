flatten chain sequence as array? (recursion vs iteration, see: https://www.quora.com/In-Python-which-is-more-efficient-to-use-recursion-or-iteration)
middleware <--- as chain + decorators
trigger chains via Event or Queue, not include???

Chains: additional methods like .on, .when, .join, .merge can be constructed combining "middleware. Try to avoid nested calls (!)

Chains as "lazy" computations. 


asyncmethod decorators - handle exceptions inside decorated func!

"features", "flavors" - separate dependencies from 3rd-party packs (redis, ...)


Query.get_records - method which always returns list or raises error
Query.get_response - mode generic method, returns named tuple {response, error, data - list or object}
TRANSPORT MEDIA MESSAGE SHOULD BE ONE TYPE FOR ALL TRANSPORTS!
class Message:
    result
    error
    payload
Chains: move Failure state from step into message?
Chains should be last - it builds array of deferred methods,
where result computed only after consumption. override right equal __eq.....???

===
amqp ... chain 
graphana?

refactor HttpTemplate to be more consistent with AmqpTemplates

expected_response_code for http-based resources (idea borrowed from influxdb-python package)
async Influx: https://aioinflux.readthedocs.io/en/stable/usage.html


implement Influx query with "select  from": 
            ####### SELECT * FROM "a_year"."downsampled_orders" LIMIT 5 
            ####### Notice that we fully qualify (that is, we use the syntax "<retention_policy>"."<measurement>") downsampled_orders in the second SELECT statement. We must specify the RP in that query to SELECT data that reside in an RP other than the DEFAULT RP

